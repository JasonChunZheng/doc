%!TEX root = paper.tex
%
% AMRClaw
%
% Lead currently:  Marsha Berger
%
\pagebreak
\subsection{\amrclaw}
Fortran code in the \amrclaw repository performs block structured adaptive mesh
refinement \cite{BO,BC} for both 
Clawpack and Geoclaw  applications.
A short overview is given
here to set the stage for a description of recent changes.
\amrclaw includes: 
\begin{itemize}
\item
Coordinating the flagging of points where refinement is needed,
with a variety of criteria possible for flagging cells that need refinement
from each level to the next finer level (including Richardson extrapolation,
gradient testing, or user-specified criteria).  See
\url{http://www.clawpack.org/flag.html}
\item
Organizing the flagged points into efficient grid
patches at the next finer level, using the algorithm of
\cite{mjb-rig:cluster};
\item
Initializing newly created fine grids, both solution and
auxiliary arrays ({\em e.g. velocity fields, bathymetry}) ;
\item
Orchestrating the time stepping since refinement levels may have
different time steps ({\em called subcycling in time});
\item
Interpolating when needed for ghost cells at the boundaries of fine patches \\
({\em needed before a time step can be taken});
\item
Updating coarse grid values covered by finer grid patches;
\item
Maintaining conservation\\
({\em correcting for mis-matched fluxes at fine--coarse boundaries}).
\end{itemize}

These algorithms have been discussed in detail in
\cite{mjb-rjl:amrclaw,LeVequeGeorgeBerger:an11}. 

An enhancement to the flagging routines that was first introduced in
\geoclaw and more recently implemented in 2D \amrclaw \todo{not yet 3D}
is the ability for the user to easily specify ``regions'' in space-time
$[x_1,x_2] \times [y_1,y_2] \times [t_1,t_2]$ in which refinement is forced to
be at least at some level $L_1$ and is allowed to be at most $L_2$.
Previously the user could enforce such conditions by writing a custom
flagging routine, but now this is handled in a general manner so that the
parameters above can all be specified in \texttt{setrun.py}.  Multiple
regions can be specified and a simple rule is used to determine the
constraints at a grid cell that lies in multiple regions, as described at
\url{http://www.clawpack.org/flag.html#refinement-regions}

The 3D \amrclaw code that disappeared in Clawpack 4.4 was reintroduced in
5.0, and has been improved with the addition of OpenMP.
The OpenMP directives in \amrclaw use 
patch-based decomposition as the basis for
parallelism. The main paradigm in structured AMR is a loop over
all patches at a level, where some operation is done on each patch
(i.e. taking a time step, finding ghost cells, conservation
updates, etc.). This lends itself easily to a {\tt parallel for} loop
construct where the each iteration of the loop corresponds to a
grid at that level. Dynamic scheduling is used with a chunk size
of one, so that one thread is assigned one patch at a time. 
To help with load balancing, patches at
each level are sorted from largest to smallest workload when they
are first created, using
the total number of cells in the grid as an indicator of work.
This same approach is now used in 3D.  

Note that this approach causes a memory bulge. Each thread
must have its own scratch arrays to save the incoming and
outgoing waves and fluxes for future conservation fix-ups. 
The bulge is directly proportional to the number
of threads executing. For stack-based memory allocation per
thread, the use of the environmental variable to increase the
{\tt OMP\_STACKSIZE} limit is necessary.

\todo{Do we want to include any parallel efficiency results?}

Auxiliary arrays are used to store data that describes the problem (e.g.
variable material parameters, topography in \geoclaw, etc.) and the routine
\texttt{setaux} must be provided by the user to set these values each time a
new grid patch is created.  For some applications (such as topography in
\geoclaw) computing these values can be time-consuming.  In Clawpack 5.2,
this code was improved to allow copying of values from previous patches at
the same level where possible at each regridding time. 
This is backward compatible, since no harm is done if previously
written routines are used that still compute and overwrite instead of
checking the flag.  

A new capability added in both 2D and 3D is spatially varying
boundary conditions.  \todo{Is this new, or just a bug fix?}
For a single grid, it is a simple matter to
compute the location of the ghost cells that extend
outside the computational domain and set them appropriately.
With AMR however, the boundary condition routine can be called
for a grid located anywhere in the domain, and may contain fewer
or larger numbers of ghost cells. The boundary condition routines
must be written in a rather unusual way that does not assume it
is always setting the same number of ghost cells, or that the
same number of reflected cells inside the domain always exist.



%\begin{itemize}
%    \item added 3d with OpenMP, 
%    \item added regions
%    \item other changes motivated by Geoclaw
%    \item Spatially varying boundary conditions
%\end{itemize}

\ignore{
The 3D branch of amrclaw
was lagging, but with the recent release of Clawpack 5.2 it is 
starting to catch up.

This was partly motivated
by the Geoclaw extensions of \cite{Mandli} to storm surge
calculations.  For use in forecasting, storm surge computations today
must take less than two hours. Even though the shallow water
equations are 2D, and by being adaptive, the code saves a lot
of time, a typical run was taking twice that, and potentially much more
for higher accuracy with more refinement. 

Parallel efficiency and overall runtime is one aspect that has 
received more attention in Clawpack 5.x. 
Another motivation is the new emphasis on 3D. The target for
Clawpack is desktop computing, so multicore machines with 8, 32 or
64 cores running OpenMP is the target.  Other frameworks exist
for large scale adaptive calculations \cite{BoxLib}, and a new
framework called ForestClaw \cite{DonnaCarlos} based on Clawpack
is being developed.

Some code that initialized newly
created fine grids was reorganized to save time in one of the
more time-consuming parts of the code.  Previous to 5.2, Geoclaw 
called the bathymetry routines to initialize each new grid.
These are expensive operations. A region can have several
overlapping  data files where each cell has multiple intersections 
that need to be computed. Also, data files in lat-long
coordinates are more complicated.  Since it is a common occurrence 
for new grids to overlap olds ones, or for pre-specified regions
to exist in the same location for long periods of time, the code
was reorganized to copy this auxiliary information whenever
possible, and a flag is set if data exists.
}
